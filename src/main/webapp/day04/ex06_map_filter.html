<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>map, some, every, filter, reduce</title>
	</head>
	<body>
		<script type="text/javascript">
		/* 
			map : 배열 내의 모든 요소에 대해서 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환
		*/
			const numbers = [1, 4, 9, 16];
			// const result = numbers.map(콜백함수);
			 
			const result = numbers.map(function (num) {
				// 배열의 각 요소마다 *2 를 한다
				return num * 2;
			});
			console.log(result);
			
			// 이때, num 은 numbers 배열의 각각의 요소를 말함
			const result2 = numbers.map(num=>num * 2 );
			console.log(result2);
			
			// 현실에서는 DB 정보 또는 제공하는 정보가 객체인 경우가 많다
			class Student{
				// 생성자
				constructor(name, kor, eng, math){
					this.name = name;
					this.kor = kor;
					this.eng = eng;
					this.math = math;
				}
			}
			
			const stu1= new Student('홍길동', 95, 87, 75);
			const stu2= new Student('김길동', 67, 80, 100);
			const stu3= new Student('고길동', 89, 75, 80);
			const stu4= new Student('최길동', 48, 52, 98);
			
			const stu=[stu1, stu2, stu3, stu4];
			console.log(stu);
			console.log("영어 점수 : ", stu.map(k=>k.eng));
			
			/* some : 배열 안에서 주어진 조건이 하나라도 만족하면 true (or=|| 개념) */
			console.log("숫자가 7 이상인 숫자 있나요? : ", numbers.some(k => k>=7));						// 9,16 있음 T
			console.log("수학 점수가 100점인 학생이 있나요? : ", stu.some(k => k.math=100));		// stu2 100있음 T
			console.log("영어 점수가 50점 미만인 학생이 있나요? : ", stu.some(k => k.eng<50));		// 없음 F
			
			/* every : 배열 안의 모든 요소가 주어진 조건이 모두 만족하면 true (and=&& 개념) */
			console.log("숫자가 모두 7 이상 인가요? : ", numbers.every(k => k>=7));							// 1,4 있음 F
			console.log("수학 점수가 모두 70점 이상 인가요? : ", stu.every(k => k.math>=70));		// 모두 70이상 T
			
			/* filter : 배열 안의 요소 중 주어진 조건에 만족하는 요소들만 새로운 배열로 반환 (=조건에 만족하는 요소들로 새로운 배열 생성) */
			console.log("숫자 중 홀수만 출력 : ", numbers.filter(k => k%2===0));									// 4,16
			console.log("영어 점수가 80점 이상인 학생만 출력 : ", stu.filter(k => k.eng>=80));			// stu1, stu2
			
			/* 
				reduce : 배열의 각 요소에 주어진 리듀스함수를 실행하고, 하나의 결과값을 반환
									주로 누적합, 중복 제거에 사용
				
				reduce 함수 : acc(누적값), cur(현재값), idx(현재 인덱스), src(원본 배열)	
			
			형식)
				배열.reduce((acc, cur, idx, src)=>{
					내용;
					return 리턴값
				}, 초기값);
						
						리턴값은 acc로 다시 되돌아간다
			*/
			console.log(`-----------------------------------------------------------------------------------`);
			
			const numbers2 = [1, 4, 9, 16];
			numbers2.reduce((acc, cur, idx, src)=>{
				console.log(`acc : ${acc}, cur : ${cur}, idx : ${idx}, src : ${src}`);
				return acc				// 리턴값이 acc로 다시 들어간다(초기값이 0이기 때문에 acc의 값은 전부 0)
			}, 0);
			
			console.log(`-----------------------------------------------------------------------------------`);
			
			numbers2.reduce((acc, cur, idx, src)=>{
				console.log(`acc : ${acc}, cur : ${cur}, idx : ${idx}, src : ${src}`);
				return acc				// 리턴값이 acc로 다시 들어간다(초기값이 1이기 때문에 acc의 값은 전부 1)
			}, 1);
			
			console.log(`-----------------------------------------------------------------------------------`);
			
			numbers2.reduce((acc, cur, idx, src)=>{
				console.log(`acc : ${acc}, cur : ${cur}, idx : ${idx}, src : ${src}`);
				return acc+cur				// 리턴값이 acc로 다시 들어간다 (초기값 0+현재값)
			}, 0);
			
			console.log(`-----------------------------------------------------------------------------------`);
			
			const result3=numbers2.reduce((acc, cur, idx, src)=>{
				return acc+cur	;			// 리턴값이 acc로 다시 들어간다 (초기값 0+현재값)
			}, 0);
			console.log(`numbers2 배열의 acc 누적값 결과 : ${result3}`);
			
			console.log(`-----------------------------------------------------------------------------------`);
			
			const fruits=["사과", "딸기", "배", "참외", "딸기", "수박"];
			
			// 비어있는 배열에서 includes(현재값)을 이용해서 중복 제거
			// includes() 메소드는 배열의 항목에 특정 값이 포함되어 있는지를 판단하여
			console.log(fruits);
			// 초기값을 비어있는 배열로 지정, 이유는 result4에 배열로 반환하기 위함
			const result4=fruits.reduce((acc, cur)=>{
				if(acc.includes(cur)=== false){
					// push : 배열에 삽입
					acc.push(cur);
				}
				return acc;
			},[]);
			// 중복을 제거한 결과 result4
			console.log(result4);
		</script>
	</body>
</html>